import logging
import sys
import os

# Add the src directory to the Python path
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from src.core import (
    parse_verilog_to_dag,
    GadgetTransformer,
    CNFEncoder,
    solve_and_report,
    FaultModel
)
from src.core.output_comparator import add_output_mismatch_clauses

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def check_vulnerability(verilog_file: str, max_faults: int = 3, num_cycles: int = 1) -> None:
    """
    Check a circuit for fault injection vulnerabilities.
    
    Args:
        verilog_file: Path to the Verilog file
        max_faults: Maximum number of faults per cycle
        num_cycles: Number of cycles for fault injection
    """
    logger.info(f"Analyzing circuit: {verilog_file}")
    
    # Step 1: Parse Verilog to DAG
    logger.info("Parsing Verilog file...")
    dag = parse_verilog_to_dag(verilog_file)
    
    # Step 2: Transform circuit with fault gadgets
    logger.info("Adding fault gadgets...")
    fault_model = FaultModel(
        max_faults_per_cycle=max_faults,
        max_cycles=num_cycles,
        allowed_fault_types={"bit_flip", "set_1", "set_0"},
        allowed_gate_types={"logic", "memory"}
    )
    transformer = GadgetTransformer(dag.graph, dag.fault_points, fault_model)
    transformed_dag = transformer.transform()
    
    # Step 3: Encode to CNF
    logger.info("Encoding to CNF...")
    encoder = CNFEncoder(transformed_dag, fault_model)
    
    # Add constraints
    encoder.add_constraint_max_faults(max_faults)
    
    # Add time constraints if using multiple cycles
    if num_cycles > 1:
        encoder.add_nc_time_constraint(transformer.get_time_control_vars(), num_cycles)
    
    # Add output mismatch condition
    add_output_mismatch_clauses(encoder, [("out", "out_protected")], "oflag")
    
    # Get CNF and variable mapping
    cnf = encoder.get_cnf()
    var_map = encoder.get_var_map()
    
    # Step 4: Solve and analyze
    logger.info("Solving SAT instance...")
    solve_and_report(
        cnf=cnf,
        var_map=var_map,
        keys_to_monitor=["out", "out_protected", "oflag"] + 
                       [f"c{g}_t{t}" for g in ["1", "2", "3"] for t in range(num_cycles)]
    )

def main():
    """Main function to demonstrate vulnerability checking."""
    # Example usage with test circuit
    check_vulnerability("../examples/test_circuit.v", max_faults=3, num_cycles=2)

if __name__ == "__main__":
    main() 
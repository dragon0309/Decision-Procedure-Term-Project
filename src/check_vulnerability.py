#!/usr/bin/env python3
import argparse
import json
import networkx as nx
from typing import Dict, List, Set, Optional
from pysat.formula import CNF
from core.verilog_parser import parse_verilog_to_dag
from core.gadget_transformer import GadgetTransformer
from core.cnf_encoder import CNFEncoder
from core.fault_model import FaultModel, FaultType, GateType
from pysat.solvers import Glucose3

def parse_args():
    parser = argparse.ArgumentParser(description='Check circuit vulnerability to fault injection')
    parser.add_argument('--config', help='JSON configuration file (overrides other arguments if provided)')
    parser.add_argument('verilog_file', nargs='?', help='Verilog file to analyze')
    parser.add_argument('--max-faults', type=int, default=1, help='Maximum faults per cycle')
    parser.add_argument('--max-cycles', type=int, default=1, help='Maximum number of cycles')
    parser.add_argument('--fault-types', nargs='+', default=['bit_flip'], 
                       choices=['bit_flip', 'set_1', 'set_0'],
                       help='Allowed fault types')
    parser.add_argument('--gate-types', default='both',
                       choices=['logic', 'memory', 'both'],
                       help='Allowed gate types')
    parser.add_argument('--output', help='Output file for results')
    args = parser.parse_args()

    # If a config file is provided or no verilog_file is specified, try to load from JSON
    if args.config or not args.verilog_file:
        config_file = args.config if args.config else 'config.json'  # Default to config.json if not specified
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
            
            # Override command-line arguments with JSON values if present
            args.verilog_file = config.get('verilog_file', args.verilog_file)
            args.max_faults = config.get('max_faults', args.max_faults)
            args.max_cycles = config.get('max_cycles', args.max_cycles)
            args.fault_types = config.get('fault_types', args.fault_types)
            args.gate_types = config.get('gate_types', args.gate_types)
            args.output = config.get('output', args.output)
            
            # Validate required field
            if not args.verilog_file:
                raise ValueError("verilog_file must be specified in the JSON config or as a command-line argument")
            
        except FileNotFoundError:
            raise FileNotFoundError(f"Configuration file {config_file} not found")
        except json.JSONDecodeError:
            raise ValueError(f"Invalid JSON format in {config_file}")

    return args

def check_vulnerability(verilog_file: str, fault_model: FaultModel) -> Dict:
    """Check circuit vulnerability to fault injection."""
    # Parse Verilog to DAG
    dag_builder = parse_verilog_to_dag(verilog_file)
    
    # Transform DAG with fault gadgets
    transformer = GadgetTransformer(dag_builder.graph, fault_model)
    transformer.transform()
    
    # Create protected DAG (copy of original)
    protected_dag = dag_builder.graph.copy()
    
    # Encode to CNF
    encoder = CNFEncoder(dag_builder.graph, fault_model)
    encoder.add_per_cycle_constraints()
    encoder.add_max_cycles_constraint()
    encoder.add_fault_gadget_constraints()
    encoder.add_output_mismatch_constraints(protected_dag)
    
    # Get CNF formula and variable map
    clauses, var_map = encoder.get_cnf()
    
    # Create CNF formula
    cnf = CNF()
    for clause in clauses:
        cnf.append(clause)
    
    # Solve CNF using SAT solver
    # Create solver instance
    solver = Glucose3()
    
    # Add all clauses to solver
    for clause in cnf:
        solver.add_clause(clause)
    
    # Check satisfiability
    if solver.solve():
        # Get the satisfying assignment
        model = solver.get_model()
        
        # Extract fault assignments and output values
        fault_assignments = {}
        output_values = {}
        mismatch_detected = False
        
        # Parse the model to extract relevant information
        for var_name, var_id in var_map.items():
            if var_id <= len(model):
                value = model[var_id - 1] > 0  # Convert to boolean
                
                # Check for fault control variables
                if var_name.startswith('c_'):
                    fault_assignments[var_name] = value
                    
                # Check for output variables
                elif var_name in [n for n in protected_dag.nodes() if protected_dag.out_degree(n) == 0]:
                    output_values[var_name] = value
                    
                # Check for mismatch variables
                elif var_name in encoder.mismatch_variables.values():
                    if value:
                        mismatch_detected = True
        
        solver.delete()
        
        return {
            'vulnerable': mismatch_detected,
            'fault_assignments': fault_assignments,
            'output_values': output_values
        }
    else:
        solver.delete()
        return {
            'vulnerable': False,
            'fault_assignments': {},
            'output_values': {}
        }

def main():
    args = parse_args()
    
    # Create fault model
    fault_model = FaultModel(
        max_faults_per_cycle=args.max_faults,
        max_cycles=args.max_cycles,
        fault_types={FaultType(ft) for ft in args.fault_types},
        gate_types=GateType(args.gate_types)
    )
    
    # Check vulnerability
    results = check_vulnerability(args.verilog_file, fault_model)
    
    # Output results
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=2)
    else:
        print(json.dumps(results, indent=2))

if __name__ == '__main__':
    main()